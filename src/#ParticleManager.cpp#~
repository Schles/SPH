#include "ParticleManager.h"


ParticleManager::ParticleManager(){
    particlesBB = 0;
    particlesFluid = 0;

}

void ParticleManager::createSetup(unsigned int i, double h){
    Eigen::Vector3f start;
    Eigen::Vector3f end;
    Eigen::Vector3f density;

    double s = 0.2;

    unsigned int size;
    
    double fluidSize = 0.3;
    double bbSize = 0.5;

    
    switch(i){
        case 1: // Presentation example
            createTestSetup1();
            break;

        case 2: // 2d example
	  fluidSize = 0.25;
	  start = Eigen::Vector3f(-fluidSize, -fluidSize, -0.0);
	  end = Eigen::Vector3d(fluidSize, fluidSize, 0.0);

	  density = Eigen::Vector3d(6, 6, 1);

	  createFluidParticles(start, end, density);

	  bbSize = 0.4;
	    
	  start = Eigen::Vector3d(-bbSize,-bbSize, -0.2);;
	  end = Eigen::Vector3d(bbSize, bbSize, 0.2);

	  //  	  createBoundingBox(start, end, 1);

	  break;


        case 3: // f√§llt einfach durch den boden

	  fluidSize = 0.1;
	  start = Eigen::Vector3d(-fluidSize, -fluidSize, -fluidSize);
	  end = Eigen::Vector3d(fluidSize, fluidSize, fluidSize);

	  density = Eigen::Vector3d(9, 9, 9);
	  createFluidParticles(start, end, density);

	  bbSize = 0.1;
	    
	  start = Eigen::Vector3d(-bbSize, -bbSize, -bbSize);;
	  end = Eigen::Vector3d(bbSize * 3, bbSize, bbSize);

	    createBoundingBox(start, end, h/2);
          break;


        case 4: // 2d example
	  
	  fluidSize = 0.0;
	  start = Eigen::Vector3d(-fluidSize, -fluidSize, -fluidSize);
	  end = Eigen::Vector3d(fluidSize, 3*fluidSize, fluidSize);

	  density = Eigen::Vector3d(1, 1, 1);

	  createFluidParticles(start, end, density);

	  bbSize = 0.05;
          start = Eigen::Vector3d(-bbSize, 4* -bbSize, -bbSize);;
          end = Eigen::Vector3d(bbSize, 4* bbSize, bbSize);


	   createBoundingBox(start, end, h/2);

	  break;

        case 5: // 2d example
	  fluidSize = 0.3;
	  start = Eigen::Vector3d(-fluidSize, -fluidSize, -fluidSize);
	  end = Eigen::Vector3d(fluidSize, fluidSize, fluidSize);

	  density = Eigen::Vector3d(15, 15, 15);

	  createFluidParticles(start, end, density);


	  bbSize = 0.6;
          start = Eigen::Vector3d(-bbSize, -bbSize, -bbSize);;
          end = Eigen::Vector3d(bbSize, bbSize, bbSize);


	  createBoundingBox(start, end, h/4);

	  break;
	  
    case 6:
      s = 0.1;
      start = Eigen::Vector3d(-s, -s, -s);
      end = Eigen::Vector3d(s, s, s);

      density = Eigen::Vector3d(10, 10, 10);

      createFluidParticles(start, end, density);

      start = Eigen::Vector3d(-s, -0.3, -0.1);;
      end = Eigen::Vector3d(s, 0.6, 0.1);


      size = m_vertices_fluid_particles.size();

      std::cout << "size " << size << std::endl;
	
      m_vertices_fluid_particles.resize(size + 1);
      m_velocities.resize(size + 1);
      m_vertices_attribute.resize(size + 1);
      m_materials.resize(size + 1);

      particlesFluid++;
      
      m_vertices_fluid_particles[size] = { 0, 0, 0 };
      m_vertices_attribute[size] = 1;
      m_materials[size] = { 1, 1, 1};

            createBoundingBox(start, end, 1);

      break;
	    
	    
        default:
            break;
    }
}

/*
 *  start: Start Vector of the Particle Field
 *  end: End Vector
 *  density: Vector with amount of particle in the axis. density[1] = 10, 10 particles on the y axis
 */

void ParticleManager::createFluidParticles(Eigen::Vector3d start, Eigen::Vector3d end, Eigen::Vector3d density){

  Particles* particles = new Particles();
    
  unsigned int memAllocs = density[0] * density[1] * density[2];

  
  
  particlesFluid += memAllocs;

  particles->position.resize(memAllocs);
  particles->position0.resize(memAllocs);
  particles->velocity.resize(memAllocs);
  particles->color.resize(memAllocs);


  //  m_fluid_position_output.resize(memAllocs);
  resizeOutputBuffer(0, memAllocs);
  
  // m_fluid_color_output.resize(memAllocs);
  /*


    m_vertices_fluid_particles.resize( m_vertices_fluid_particles.size() + memAllocs);
    m_velocities.resize(m_velocities.size() + memAllocs);
    m_vertices_attribute.resize(m_vertices_attribute.size() + memAllocs);
    m_materials.resize(m_vertices_attribute.size() + memAllocs);
  */

  int memAddr = 0;

  // create water particles
  for(int i = 0; i < density[0]; ++i)
    for (int j = 0; j < density[1]; ++j)
      for(int k = 0; k < density[2]; ++k)
	{

	  float x;
	  if(density[0] == 1)
	    x = start[0] + (end[0] - start[0]) / 2.0;
	  else
	    x = start[0] + i * (end[0] - start[0]) / (density[0] - 1);


	  float y;
	  if(density[1] == 1)
	    y = start[1] + (end[1] - start[1]) / 2.0;
	  else
	    y = start[1] + j * (end[1] - start[1]) / (density[1] - 1);

	  float z;
	  if(density[2] <= 1)
	    z = start[2] + (end[2] - start[2]) / 2.0;
	  else
	    z = start[2] + k * (end[2] - start[2]) / (density[2] - 1);


	  memAddr = i * density[1] * density[2] + j * density[2] + k;



	  particles->position0[memAddr] = { x, y, z};

	  //m_vertices_attribute[memAddr] = 1;
	  // particles->velocity[memAddr] = Eigen::Vector3d(0.0, 0.0, 0.0);
	  particles->color[memAddr] = Eigen::Vector3d(0.0, 0.0, 0.0);;

	}

  m_particleObjects.push_back(particles);
    
  std::cout << "Created " << memAllocs << " particles." << std::endl;
}

void ParticleManager::createTestSetup1()
{
	m_vertices_fluid_particles.resize(13200);
	m_velocities.resize(13200);
	m_vertices_attribute.resize(13200);

	int offset = 0;

	// create fluid particles 2m * 2m, 0.1m density
	for (int i = 1; i < 20; i++)
		for (int j = 1; j < 20; j++)
			for (int k = 1; k < 20; k++)
			{
				float x = i / 10.0;
				float y = j / 10.0;
				float z = k / 10.0;

				m_vertices_fluid_particles[offset + i * 400 + j * 20 + k] = { x, y, z };
				m_vertices_attribute[offset + i * 400 + j * 20 + k] = 1;

			}

	// create bounding box 3m(height) * 2m * 4m

	offset += 8000;

	for (int i = 0; i < 30; i++)
		for (int j = 0; j < 20; j++)
		{
			float x = 0.0;
			float y = i / 10.0;
			float z = j / 10.0;;

			m_vertices_fluid_particles[offset + i * 20 + j] = { x, y, z };
			m_vertices_attribute[offset + i * 20 + j] = 0;

			x = 4.0;
			m_vertices_fluid_particles[offset + 600 + i * 20 + j] = { x, y, z };
			m_vertices_attribute[offset + 600 + i * 20 + j] = 0;
		}

	offset += 1200;

	for (int i = 0; i < 30; i++)
		for (int j = 0; j < 40; j++)
		{
			float x = j / 10.0;
			float y = i / 10.0;
			float z = 0.0;

			m_vertices_fluid_particles[offset + i * 40 + j] = { x, y, z };
			m_vertices_attribute[offset + i * 40 + j] = 0;

			z = 2.0;
			m_vertices_fluid_particles[offset + 1200 + i * 40 + j] = { x, y, z };
			m_vertices_attribute[offset + 1200 + i * 40 + j] = 0;
		}

	offset += 2400;

	for (int i = 0; i < 20; i++)
		for (int j = 0; j < 40; j++)
		{
			float x = j / 10.0;
			float y = 0.0;
			float z = i / 10.0;

			m_vertices_fluid_particles[offset + i * 40 + j] = { x, y, z };
			m_vertices_attribute[offset + i * 40 + j] = 0;

			/*y = 3.0;
			m_vertices_fluid_particles[offset + 800 + i * 40 + j] = { x, y, z };
 			m_vertices_attribute[offset + 800 + i * 40 + j] = 0;*/
		}

	offset += 800;

	particlesBB = 4400;
	particlesFluid = 8000;


}

void ParticleManager::createBoundingBox(Eigen::Vector3d start, Eigen::Vector3d end, double h){

  Boundary* particles = new Boundary();
  /*
    int density[3] = {
      (end[0] - start[0]) / h,
      (end[1] - start[1]) / h,
      (end[2] - start[2]) / h 
    };
*/

    int density[3] = {
      (end[0] - start[0]) / h,
      (end[1] - start[1]) / h,
      (end[2] - start[2]) / h 
    };
    unsigned int memAllocs = 2 * density[0] * (density[1] + 1) + 2 * (density[1] + 1) * density[2] + 2 * (density[0] - 1) * (density[2] - 1);

    particlesBB += memAllocs;

    particles->position.resize(memAllocs);
    particles->color.resize(memAllocs);
    particles->m_boundaryPsi.resize(memAllocs);

    resizeOutputBuffer(1, memAllocs);
    
    //m_vertices_fluid_particles.resize( m_vertices_fluid_particles.size() + memAllocs);
    //m_velocities.resize(m_velocities.size() + memAllocs);
    //m_vertices_attribute.resize(m_vertices_attribute.size() + memAllocs);
    //m_materials.resize(m_vertices_attribute.size() + memAllocs);

    int memOffset = 0;

    Eigen::Vector3d boundryColor(0.0,0.0,0.0);

    // Z Planes
    for(int i = 0; i < density[1] + 1; ++i)
        for (int j = 0; j < density[0]; ++j)
        {
            float x = start[0] + j * (end[0] - start[0]) / density[0];
            float y = start[1] + i * (end[1] - start[1]) / density[1];
            float z = start[2];
	    
            int memAddr = memOffset + i * density[0] + j;
            //std::cout << memAddr << ": " << i << ", " << j << std::endl;
	    
	    particles->position[memAddr] = { x, y, z };
	    particles->color[memAddr] = boundryColor;
	    

            int a = density[0]*(1 + density[1]);
            int b = i * density[0];


            memAddr = memOffset + ((density[0])*(density[1] + 1)) + (i * density[0]) + j;

            x += (end[0] - start[0]) / density[0];
            z = end[2];
	    
	    particles->position[memAddr] = { x, y, z };
            particles->color[memAddr] = boundryColor;

        }

    // X Planes
    memOffset += 2 * (density[0])*(density[1]+1);

    for(int i = 0; i < density[1] + 1; ++i)
        for (int j = 0; j < density[2]; ++j)
        {
            float x = end[0];
            float y = start[1] + i * (end[1] - start[1]) / density[1];
            float z = start[2] + j * (end[2] - start[2]) / density[2];

            int memAddr = memOffset + i * density[2] + j;

	    particles->position[memAddr] = { x, y, z };
	    particles->color[memAddr] = boundryColor;

            memAddr = memOffset + (density[1] + 1)*(density[2]) + i * density[2] + j;


            x = start[0];
            z += (end[2] - start[2]) / density[2];

	    particles->position[memAddr] = { x, y, z };
	    particles->color[memAddr] = boundryColor;
        }


    // Y Planes
    memOffset += 2 * (density[1] + 1) * density[2];

    for (int i = 0; i < density[0] - 1; ++i)
        for (int j = 0; j < density[2] - 1; ++j)
        {
            float x = start[0] + ( i + 1 ) * (end[0] - start[0]) / density[0];;
            float y = start[1];
            float z = start[2] + ( j + 1 ) * (end[2] - start[2]) / density[2];

            int memAddr = memOffset + i * (density[2] - 1) + j;

            particles->position[memAddr] = { x, y, z };
	    particles->color[memAddr] = boundryColor;

            memAddr = memOffset + (density[0] - 1 )*(density[2] - 1) + i * (density[2] - 1) + j;
            y = end[1];

	    particles->position[memAddr] = { x, y, z };
	    particles->color[memAddr] = boundryColor;

        }

    
    m_particleObjects.push_back(particles);
    std::cout << "Created " << memAllocs << " bounding particles." << std::endl;
}


void ParticleManager::updateFluidPositions(unsigned int point_set){
  
  for (int i = 0; i < m_particleObjects[point_set]->position.size(); ++i)
	{	  
	  // Set output postion
	  m_fluid_position_output[point_set][i][0] = (float) m_particleObjects[point_set]->position[i][0];
	  m_fluid_position_output[point_set][i][1] = (float) m_particleObjects[point_set]->position[i][1];
	  m_fluid_position_output[point_set][i][2] = (float) m_particleObjects[point_set]->position[i][2];
	  
	  
	  // Set Output colors
	  m_fluid_color_output[point_set][i][0] = (float) m_particleObjects[point_set]->color[i][0];
	  m_fluid_color_output[point_set][i][1] = (float) m_particleObjects[point_set]->color[i][1];
	  m_fluid_color_output[point_set][i][2] = (float) m_particleObjects[point_set]->color[i][2];
	  
	}


}

void ParticleManager::resizeOutputBuffer(unsigned int bufferId, unsigned int size){
  unsigned int bsize = m_fluid_position_output.size();

  m_fluid_position_output.resize(bsize + 1);
  m_fluid_position_output[bsize].resize(size);

  m_fluid_color_output.resize(bsize + 1);
  m_fluid_color_output[bsize].resize(size);
}
